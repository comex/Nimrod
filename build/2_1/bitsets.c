/* Generated by Nimrod Compiler v0.8.9 */
/*   (c) 2010 Andreas Rumpf */

typedef long int NI;
typedef unsigned long int NU;
#include "nimbase.h"

typedef struct TY101008 TY101008;
typedef struct TGenericSeq TGenericSeq;
typedef struct TNimType TNimType;
typedef struct TNimNode TNimNode;
struct TGenericSeq {
NI len;
NI space;
};
struct TNimType {
NI size;
NU8 kind;
NU8 flags;
TNimType* base;
TNimNode* node;
void* finalizer;
};
struct TNimNode {
NU8 kind;
NI offset;
TNimType* typ;
NCSTRING name;
NI len;
TNimNode** sons;
};
struct TY101008 {
  TGenericSeq Sup;
  NI8 data[SEQ_DECL_SIZE];
};
N_NIMCALL(NIM_BOOL, Bitsetin_101045)(TY101008* X_101047, NI64 E_101048);
static N_INLINE(NI64, divInt64)(NI64 A_5761, NI64 B_5762);
N_NOINLINE(void, raiseDivByZero)(void);
N_NOINLINE(void, raiseOverflow)(void);
N_NOINLINE(void, raiseIndexError)(void);
static N_INLINE(NI64, modInt64)(NI64 A_5772, NI64 B_5773);
N_NIMCALL(NI64, chckRange64)(NI64 I_5523, NI64 A_5524, NI64 B_5525);
N_NIMCALL(void, Bitsetincl_101035)(TY101008** X_101038, NI64 Elem_101039);
N_NIMCALL(void, internalAssert)(NCSTRING File_5254, NI Line_5255, NIM_BOOL Cond_5256);
N_NIMCALL(void, Bitsetexcl_101040)(TY101008** X_101043, NI64 Elem_101044);
N_NIMCALL(void, Bitsetinit_101010)(TY101008** B_101013, NI Length_101014);
N_NIMCALL(void*, newSeq)(TNimType* Typ_13004, NI Len_13005);
N_NIMCALL(void, unsureAsgnRef)(void** Dest_12026, void* Src_12027);
N_NIMCALL(void, Bitsetunion_101015)(TY101008** X_101018, TY101008* Y_101019);
static N_INLINE(NI, addInt)(NI A_5803, NI B_5804);
N_NIMCALL(void, Bitsetdiff_101020)(TY101008** X_101023, TY101008* Y_101024);
N_NIMCALL(void, Bitsetsymdiff_101025)(TY101008** X_101028, TY101008* Y_101029);
N_NIMCALL(void, Bitsetintersect_101030)(TY101008** X_101033, TY101008* Y_101034);
N_NIMCALL(NIM_BOOL, Bitsetequals_101049)(TY101008* X_101051, TY101008* Y_101052);
N_NIMCALL(NIM_BOOL, Bitsetcontains_101053)(TY101008* X_101055, TY101008* Y_101056);
extern TNimType* NTI101008; /* TBitSet */
static N_INLINE(NI64, divInt64)(NI64 A_5761, NI64 B_5762) {
NI64 Result_5763;
NIM_BOOL LOC5;
Result_5763 = 0;
if (!(B_5762 == 0)) goto LA2;
raiseDivByZero();
LA2: ;
LOC5 = (A_5761 == (IL64(-9223372036854775807) - IL64(1)));
if (!(LOC5)) goto LA6;
LOC5 = (B_5762 == -1);
LA6: ;
if (!LOC5) goto LA7;
raiseOverflow();
LA7: ;
Result_5763 = (NI64)(A_5761 / B_5762);
goto BeforeRet;
BeforeRet: ;
return Result_5763;
}
static N_INLINE(NI64, modInt64)(NI64 A_5772, NI64 B_5773) {
NI64 Result_5774;
Result_5774 = 0;
if (!(B_5773 == 0)) goto LA2;
raiseDivByZero();
LA2: ;
Result_5774 = (NI64)(A_5772 % B_5773);
goto BeforeRet;
BeforeRet: ;
return Result_5774;
}
N_NIMCALL(NIM_BOOL, Bitsetin_101045)(TY101008* X_101047, NI64 E_101048) {
NIM_BOOL Result_101061;
volatile struct {TFrame* prev;NCSTRING procname;NI line;NCSTRING filename;NI len;
} F;
F.procname = "BitSetIn";
F.prev = framePtr;
F.filename = "rod/bitsets.nim";
F.line = 0;
framePtr = (TFrame*)&F;
F.len = 0;
Result_101061 = 0;
F.line = 34;F.filename = "bitsets.nim";
if ((NU)(divInt64(E_101048, 8)) >= (NU)(X_101047->Sup.len)) raiseIndexError();
Result_101061 = !(((NI8)(X_101047->data[divInt64(E_101048, 8)] & ((NI8)(NU8)(NU)(((NI)chckRange64((NI64)((NU64)(1) << (NU64)(modInt64(E_101048, 8))), (-2147483647 -1), 2147483647))))) == ((NI8) 0)));
framePtr = framePtr->prev;
return Result_101061;
}
N_NIMCALL(void, Bitsetincl_101035)(TY101008** X_101038, NI64 Elem_101039) {
volatile struct {TFrame* prev;NCSTRING procname;NI line;NCSTRING filename;NI len;
} F;
F.procname = "BitSetIncl";
F.prev = framePtr;
F.filename = "rod/bitsets.nim";
F.line = 0;
framePtr = (TFrame*)&F;
F.len = 0;
F.line = 38;F.filename = "bitsets.nim";
internalAssert("rod/bitsets.nim", 38, (0 <= Elem_101039));
F.line = 39;F.filename = "bitsets.nim";
if ((NU)(divInt64(Elem_101039, 8)) >= (NU)((*X_101038)->Sup.len)) raiseIndexError();
if ((NU)(divInt64(Elem_101039, 8)) >= (NU)((*X_101038)->Sup.len)) raiseIndexError();
(*X_101038)->data[divInt64(Elem_101039, 8)] = (NI8)((*X_101038)->data[divInt64(Elem_101039, 8)] | ((NI8)(NU8)(NU)(((NI)chckRange64((NI64)((NU64)(1) << (NU64)(modInt64(Elem_101039, 8))), (-2147483647 -1), 2147483647)))));
framePtr = framePtr->prev;
}
N_NIMCALL(void, Bitsetexcl_101040)(TY101008** X_101043, NI64 Elem_101044) {
volatile struct {TFrame* prev;NCSTRING procname;NI line;NCSTRING filename;NI len;
} F;
F.procname = "BitSetExcl";
F.prev = framePtr;
F.filename = "rod/bitsets.nim";
F.line = 0;
framePtr = (TFrame*)&F;
F.len = 0;
F.line = 43;F.filename = "bitsets.nim";
if ((NU)(divInt64(Elem_101044, 8)) >= (NU)((*X_101043)->Sup.len)) raiseIndexError();
if ((NU)(divInt64(Elem_101044, 8)) >= (NU)((*X_101043)->Sup.len)) raiseIndexError();
(*X_101043)->data[divInt64(Elem_101044, 8)] = (NI8)((*X_101043)->data[divInt64(Elem_101044, 8)] & (NI8)((NU8) ~(((NI8)(NU8)(NU)(((NI)chckRange64((NI64)((NU64)(1) << (NU64)(modInt64(Elem_101044, 8))), (-2147483647 -1), 2147483647)))))));
framePtr = framePtr->prev;
}
N_NIMCALL(void, Bitsetinit_101010)(TY101008** B_101013, NI Length_101014) {
volatile struct {TFrame* prev;NCSTRING procname;NI line;NCSTRING filename;NI len;
} F;
F.procname = "BitSetInit";
F.prev = framePtr;
F.filename = "rod/bitsets.nim";
F.line = 0;
framePtr = (TFrame*)&F;
F.len = 0;
F.line = 47;F.filename = "bitsets.nim";
unsureAsgnRef((void**) &(*B_101013), (TY101008*) newSeq(NTI101008, Length_101014));
framePtr = framePtr->prev;
}
static N_INLINE(NI, addInt)(NI A_5803, NI B_5804) {
NI Result_5805;
NIM_BOOL LOC2;
Result_5805 = 0;
Result_5805 = (NI32)((NU32)(A_5803) + (NU32)(B_5804));
LOC2 = (0 <= (NI32)(Result_5805 ^ A_5803));
if (LOC2) goto LA3;
LOC2 = (0 <= (NI32)(Result_5805 ^ B_5804));
LA3: ;
if (!LOC2) goto LA4;
goto BeforeRet;
LA4: ;
raiseOverflow();
BeforeRet: ;
return Result_5805;
}
N_NIMCALL(void, Bitsetunion_101015)(TY101008** X_101018, TY101008* Y_101019) {
NI I_101120;
NI HEX3Atmp_101122;
NI Res_101124;
volatile struct {TFrame* prev;NCSTRING procname;NI line;NCSTRING filename;NI len;
} F;
F.procname = "BitSetUnion";
F.prev = framePtr;
F.filename = "rod/bitsets.nim";
F.line = 0;
framePtr = (TFrame*)&F;
F.len = 0;
I_101120 = 0;
HEX3Atmp_101122 = 0;
F.line = 50;F.filename = "bitsets.nim";
HEX3Atmp_101122 = ((*X_101018)->Sup.len-1);
Res_101124 = 0;
F.line = 1021;F.filename = "system.nim";
Res_101124 = 0;
F.line = 1022;F.filename = "system.nim";
while (1) {
if (!(Res_101124 <= HEX3Atmp_101122)) goto LA1;
F.line = 1021;F.filename = "system.nim";
I_101120 = Res_101124;
F.line = 50;F.filename = "bitsets.nim";
if ((NU)(I_101120) >= (NU)((*X_101018)->Sup.len)) raiseIndexError();
if ((NU)(I_101120) >= (NU)((*X_101018)->Sup.len)) raiseIndexError();
if ((NU)(I_101120) >= (NU)(Y_101019->Sup.len)) raiseIndexError();
(*X_101018)->data[I_101120] = (NI8)((*X_101018)->data[I_101120] | Y_101019->data[I_101120]);
F.line = 1024;F.filename = "system.nim";
Res_101124 = addInt(Res_101124, 1);
} LA1: ;
framePtr = framePtr->prev;
}
N_NIMCALL(void, Bitsetdiff_101020)(TY101008** X_101023, TY101008* Y_101024) {
NI I_101139;
NI HEX3Atmp_101141;
NI Res_101143;
volatile struct {TFrame* prev;NCSTRING procname;NI line;NCSTRING filename;NI len;
} F;
F.procname = "BitSetDiff";
F.prev = framePtr;
F.filename = "rod/bitsets.nim";
F.line = 0;
framePtr = (TFrame*)&F;
F.len = 0;
I_101139 = 0;
HEX3Atmp_101141 = 0;
F.line = 53;F.filename = "bitsets.nim";
HEX3Atmp_101141 = ((*X_101023)->Sup.len-1);
Res_101143 = 0;
F.line = 1021;F.filename = "system.nim";
Res_101143 = 0;
F.line = 1022;F.filename = "system.nim";
while (1) {
if (!(Res_101143 <= HEX3Atmp_101141)) goto LA1;
F.line = 1021;F.filename = "system.nim";
I_101139 = Res_101143;
F.line = 53;F.filename = "bitsets.nim";
if ((NU)(I_101139) >= (NU)((*X_101023)->Sup.len)) raiseIndexError();
if ((NU)(I_101139) >= (NU)((*X_101023)->Sup.len)) raiseIndexError();
if ((NU)(I_101139) >= (NU)(Y_101024->Sup.len)) raiseIndexError();
(*X_101023)->data[I_101139] = (NI8)((*X_101023)->data[I_101139] & (NI8)((NU8) ~(Y_101024->data[I_101139])));
F.line = 1024;F.filename = "system.nim";
Res_101143 = addInt(Res_101143, 1);
} LA1: ;
framePtr = framePtr->prev;
}
N_NIMCALL(void, Bitsetsymdiff_101025)(TY101008** X_101028, TY101008* Y_101029) {
NI I_101158;
NI HEX3Atmp_101160;
NI Res_101162;
volatile struct {TFrame* prev;NCSTRING procname;NI line;NCSTRING filename;NI len;
} F;
F.procname = "BitSetSymDiff";
F.prev = framePtr;
F.filename = "rod/bitsets.nim";
F.line = 0;
framePtr = (TFrame*)&F;
F.len = 0;
I_101158 = 0;
HEX3Atmp_101160 = 0;
F.line = 56;F.filename = "bitsets.nim";
HEX3Atmp_101160 = ((*X_101028)->Sup.len-1);
Res_101162 = 0;
F.line = 1021;F.filename = "system.nim";
Res_101162 = 0;
F.line = 1022;F.filename = "system.nim";
while (1) {
if (!(Res_101162 <= HEX3Atmp_101160)) goto LA1;
F.line = 1021;F.filename = "system.nim";
I_101158 = Res_101162;
F.line = 56;F.filename = "bitsets.nim";
if ((NU)(I_101158) >= (NU)((*X_101028)->Sup.len)) raiseIndexError();
if ((NU)(I_101158) >= (NU)((*X_101028)->Sup.len)) raiseIndexError();
if ((NU)(I_101158) >= (NU)(Y_101029->Sup.len)) raiseIndexError();
(*X_101028)->data[I_101158] = (NI8)((*X_101028)->data[I_101158] ^ Y_101029->data[I_101158]);
F.line = 1024;F.filename = "system.nim";
Res_101162 = addInt(Res_101162, 1);
} LA1: ;
framePtr = framePtr->prev;
}
N_NIMCALL(void, Bitsetintersect_101030)(TY101008** X_101033, TY101008* Y_101034) {
NI I_101177;
NI HEX3Atmp_101179;
NI Res_101181;
volatile struct {TFrame* prev;NCSTRING procname;NI line;NCSTRING filename;NI len;
} F;
F.procname = "BitSetIntersect";
F.prev = framePtr;
F.filename = "rod/bitsets.nim";
F.line = 0;
framePtr = (TFrame*)&F;
F.len = 0;
I_101177 = 0;
HEX3Atmp_101179 = 0;
F.line = 59;F.filename = "bitsets.nim";
HEX3Atmp_101179 = ((*X_101033)->Sup.len-1);
Res_101181 = 0;
F.line = 1021;F.filename = "system.nim";
Res_101181 = 0;
F.line = 1022;F.filename = "system.nim";
while (1) {
if (!(Res_101181 <= HEX3Atmp_101179)) goto LA1;
F.line = 1021;F.filename = "system.nim";
I_101177 = Res_101181;
F.line = 59;F.filename = "bitsets.nim";
if ((NU)(I_101177) >= (NU)((*X_101033)->Sup.len)) raiseIndexError();
if ((NU)(I_101177) >= (NU)((*X_101033)->Sup.len)) raiseIndexError();
if ((NU)(I_101177) >= (NU)(Y_101034->Sup.len)) raiseIndexError();
(*X_101033)->data[I_101177] = (NI8)((*X_101033)->data[I_101177] & Y_101034->data[I_101177]);
F.line = 1024;F.filename = "system.nim";
Res_101181 = addInt(Res_101181, 1);
} LA1: ;
framePtr = framePtr->prev;
}
N_NIMCALL(NIM_BOOL, Bitsetequals_101049)(TY101008* X_101051, TY101008* Y_101052) {
NIM_BOOL Result_101188;
NI I_101196;
NI HEX3Atmp_101200;
NI Res_101202;
volatile struct {TFrame* prev;NCSTRING procname;NI line;NCSTRING filename;NI len;
} F;
F.procname = "BitSetEquals";
F.prev = framePtr;
F.filename = "rod/bitsets.nim";
F.line = 0;
framePtr = (TFrame*)&F;
F.len = 0;
Result_101188 = 0;
I_101196 = 0;
HEX3Atmp_101200 = 0;
F.line = 62;F.filename = "bitsets.nim";
HEX3Atmp_101200 = (X_101051->Sup.len-1);
Res_101202 = 0;
F.line = 1021;F.filename = "system.nim";
Res_101202 = 0;
F.line = 1022;F.filename = "system.nim";
while (1) {
if (!(Res_101202 <= HEX3Atmp_101200)) goto LA1;
F.line = 1021;F.filename = "system.nim";
I_101196 = Res_101202;
F.line = 63;F.filename = "bitsets.nim";
if ((NU)(I_101196) >= (NU)(X_101051->Sup.len)) raiseIndexError();
if ((NU)(I_101196) >= (NU)(Y_101052->Sup.len)) raiseIndexError();
if (!!((X_101051->data[I_101196] == Y_101052->data[I_101196]))) goto LA3;
F.line = 64;F.filename = "bitsets.nim";
F.line = 64;F.filename = "bitsets.nim";
Result_101188 = NIM_FALSE;
goto BeforeRet;
LA3: ;
F.line = 1024;F.filename = "system.nim";
Res_101202 = addInt(Res_101202, 1);
} LA1: ;
F.line = 65;F.filename = "bitsets.nim";
Result_101188 = NIM_TRUE;
BeforeRet: ;
framePtr = framePtr->prev;
return Result_101188;
}
N_NIMCALL(NIM_BOOL, Bitsetcontains_101053)(TY101008* X_101055, TY101008* Y_101056) {
NIM_BOOL Result_101209;
NI I_101217;
NI HEX3Atmp_101221;
NI Res_101223;
volatile struct {TFrame* prev;NCSTRING procname;NI line;NCSTRING filename;NI len;
} F;
F.procname = "BitSetContains";
F.prev = framePtr;
F.filename = "rod/bitsets.nim";
F.line = 0;
framePtr = (TFrame*)&F;
F.len = 0;
Result_101209 = 0;
I_101217 = 0;
HEX3Atmp_101221 = 0;
F.line = 68;F.filename = "bitsets.nim";
HEX3Atmp_101221 = (X_101055->Sup.len-1);
Res_101223 = 0;
F.line = 1021;F.filename = "system.nim";
Res_101223 = 0;
F.line = 1022;F.filename = "system.nim";
while (1) {
if (!(Res_101223 <= HEX3Atmp_101221)) goto LA1;
F.line = 1021;F.filename = "system.nim";
I_101217 = Res_101223;
F.line = 69;F.filename = "bitsets.nim";
if ((NU)(I_101217) >= (NU)(X_101055->Sup.len)) raiseIndexError();
if ((NU)(I_101217) >= (NU)(Y_101056->Sup.len)) raiseIndexError();
if (!!(((NI8)(X_101055->data[I_101217] & (NI8)((NU8) ~(Y_101056->data[I_101217]))) == ((NI8) 0)))) goto LA3;
F.line = 70;F.filename = "bitsets.nim";
F.line = 70;F.filename = "bitsets.nim";
Result_101209 = NIM_FALSE;
goto BeforeRet;
LA3: ;
F.line = 1024;F.filename = "system.nim";
Res_101223 = addInt(Res_101223, 1);
} LA1: ;
F.line = 71;F.filename = "bitsets.nim";
Result_101209 = NIM_TRUE;
BeforeRet: ;
framePtr = framePtr->prev;
return Result_101209;
}
N_NOINLINE(void, bitsetsInit)(void) {
volatile struct {TFrame* prev;NCSTRING procname;NI line;NCSTRING filename;NI len;
} F;
F.procname = "bitsets";
F.prev = framePtr;
F.filename = "rod/bitsets.nim";
F.line = 0;
framePtr = (TFrame*)&F;
F.len = 0;
framePtr = framePtr->prev;
}

